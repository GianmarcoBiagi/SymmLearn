<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · SymmLearn.jl</title><meta name="title" content="API · SymmLearn.jl"/><meta property="og:title" content="API · SymmLearn.jl"/><meta property="twitter:title" content="API · SymmLearn.jl"/><meta name="description" content="Documentation for SymmLearn.jl."/><meta property="og:description" content="Documentation for SymmLearn.jl."/><meta property="twitter:description" content="Documentation for SymmLearn.jl."/><meta property="og:url" content="https://github.com/GianmarcoBiagi/SymmLearn/api/"/><meta property="twitter:url" content="https://github.com/GianmarcoBiagi/SymmLearn/api/"/><link rel="canonical" href="https://github.com/GianmarcoBiagi/SymmLearn/api/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SymmLearn.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../installation/">Installation</a></li><li><a class="tocitem" href="../usage/">Usage</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li class="is-active"><a class="tocitem" href>API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/GianmarcoBiagi/SymmLearn" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="SymmLearn.jl-API"><a class="docs-heading-anchor" href="#SymmLearn.jl-API">SymmLearn.jl API</a><a id="SymmLearn.jl-API-1"></a><a class="docs-heading-anchor-permalink" href="#SymmLearn.jl-API" title="Permalink"></a></h1><p>This page lists all <strong>user-facing functions</strong> in <code>SymmLearn.jl</code>.   These are the primary entry points you will use to process data, build models, train them, and make predictions.</p><ul><li><a href="#SymmLearn.xyz_to_nn_input"><code>SymmLearn.xyz_to_nn_input</code></a></li><li><a href="#SymmLearn.build_species_models"><code>SymmLearn.build_species_models</code></a></li><li><a href="#SymmLearn.train_model!"><code>SymmLearn.train_model!</code></a></li><li><a href="#SymmLearn.dispatch"><code>SymmLearn.dispatch</code></a></li><li><a href="#SymmLearn.predict_forces"><code>SymmLearn.predict_forces</code></a></li><li><a href="#SymmLearn.loss"><code>SymmLearn.loss</code></a></li></ul><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.xyz_to_nn_input" href="#SymmLearn.xyz_to_nn_input"><code>SymmLearn.xyz_to_nn_input</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">xyz_to_nn_input(file_path::String)</code></pre><p>Process an XYZ file containing atomic structures and energies to generate datasets for neural network training.</p><p><strong>Arguments</strong></p><ul><li><code>file_path::String</code>: Path to the XYZ file containing coordinates, species, lattice cells, and energy values.</li></ul><p><strong>Returns</strong></p><p>A tuple with:</p><ol><li><code>x_train::Array, y_train::Vector{Sample}</code>: Training inputs and targets.</li><li><code>x_val::Array, y_val::Vector{Sample}</code>: Validation inputs and targets.</li><li><code>x_test::Array, y_test::Vector{Sample}</code>: Test inputs and targets.</li><li><code>(energy_mean::Float32, energy_std::Float32)</code>: Energy normalization statistics.</li><li><code>unique_species::Vector{String}</code>: Unique atomic species in the dataset.</li><li><code>species_idx::Dict{String,Int}</code>: Mapping from species to integer indices.</li><li><code>all_cells::Vector{Matrix{Float32}}</code>: Lattice cell matrices for each configuration.</li></ol><p><strong>Description</strong></p><p>Steps performed:</p><ol><li>Extract structures, species, cells, and energies with <code>extract_data</code>.</li><li>Convert positions and forces into atom-wise inputs with <code>prepare_nn_data</code>.</li><li>Normalize energies and rescale forces consistently, then split into train/val/test sets with <code>data_preprocess</code>.</li></ol><p><strong>Dependencies</strong></p><ul><li><code>extract_data(file_path)</code>: Parses raw atomic data from the XYZ file.  </li><li><code>prepare_nn_data(dataset, species, unique_species)</code>: Builds NN inputs and forces arrays.  </li><li><code>data_preprocess(nn_input_dataset, all_energies, all_forces)</code>: Normalizes and splits the dataset.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">file_path = &quot;example_structures.xyz&quot;
x_train, y_train, x_val, y_val, x_test, y_test, (energy_mean, energy_std), unique_species, species_idx, all_cells = xyz_to_nn_input(file_path)
println(&quot;Training set size: &quot;, length(x_train))
println(&quot;Unique species: &quot;, unique_species)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.build_species_models" href="#SymmLearn.build_species_models"><code>SymmLearn.build_species_models</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_species_models(unique_species::Vector{String}, species_idx::Dict{String,Int}, G1_number::Int, R_cutoff::Float32)</code></pre><p>Creates an array of Flux <code>Chain</code> models, one for each unique species.   The array is indexed according to <code>species_idx</code>, so that each species can be dispatched to the correct model based on its numeric index.  </p><p><strong>Arguments</strong></p><ul><li><code>unique_species::Vector{String}</code>: List of species names.</li><li><code>species_idx::Dict{String,Int}</code>: Mapping from species name to numeric index.</li><li><code>G1_number::Int</code>: Number of neurons in the G1Layer.</li><li><code>R_cutoff::Float32</code>: Cutoff radius for the G1Layer.</li></ul><p><strong>Returns</strong></p><ul><li><code>species_models::Vector{Chain}</code>: Array of models, ready for Enzyme differentiation.</li></ul><pre><code class="language-julia hljs">unique_species = [&quot;H&quot;, &quot;O&quot;]
species_idx = Dict(&quot;H&quot;=&gt;1, &quot;O&quot;=&gt;2)
G1_number = 5
R_cutoff = 5.0f0

models = build_species_models(unique_species, species_idx, G1_number, R_cutoff; depth=2)
println(models[1])  # model for H
println(models[2])  # model for O</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.train_model!" href="#SymmLearn.train_model!"><code>SymmLearn.train_model!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">train_model!(model, x_train, y_train, x_val, y_val, 
             λ=1.0f0; forces=true, initial_lr=0.01, min_lr=1e-6, decay_factor=0.1, 
             patience=50, epochs=1000, batch_size=32, verbose=false, lattice=nothing)</code></pre><p>Train a neural network model to predict total energies (and optionally forces)  for atomic structures using mini-batch gradient descent, adaptive learning rate,  and early stopping.</p><p><strong>Arguments</strong></p><ul><li><p><code>model::Flux.Chain</code>   Neural network to train. Can combine multiple branches for different atomic species.</p></li><li><p><code>x_train::Any</code>   Training atomic structures, either batched or compatible with <code>distance_layer</code>.</p></li><li><p><code>y_train::Vector{Sample}</code>   Ground-truth labels containing <code>.energy</code> and <code>.forces</code> for training.</p></li><li><p><code>x_val::Any</code>   Validation atomic structures, same format as <code>x_train</code>.</p></li><li><p><code>y_val::Vector{Sample}</code>   Ground-truth labels for validation.</p></li><li><p><code>λ::Float32</code> (default = 1.0)   Weight applied to the force loss relative to the energy loss.</p></li><li><p><code>forces::Bool</code> (default = true)   If true, include force loss in addition to energy loss.</p></li><li><p><code>initial_lr::Float32</code> (default = 0.01)   Initial learning rate for the Adam optimizer.</p></li><li><p><code>min_lr::Float32</code> (default = 1e-6)   Minimum allowed learning rate; training stops decaying when reached.</p></li><li><p><code>decay_factor::Float32</code> (default = 0.1)   Factor by which to multiply the learning rate if validation loss plateaus.</p></li><li><p><code>patience::Int</code> (default = 50)   Number of epochs without improvement before reducing the learning rate.</p></li><li><p><code>epochs::Int</code> (default = 1000)   Maximum number of training epochs.</p></li><li><p><code>batch_size::Int</code> (default = 32)   Number of structures per mini-batch.</p></li><li><p><code>verbose::Bool</code> (default = false)   If true, prints progress, learning rate changes, and final results.</p></li><li><p><code>lattice::Union{Nothing, Matrix{Float32}}</code> (default = nothing)   Optional 3×3 lattice matrix if distances should be computed under PBC.</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>best_model::Flux.Chain</code>   Model achieving the lowest validation loss during training.</p></li><li><p><code>loss_tr::Vector{Float32}</code>   Training loss per epoch.</p></li><li><p><code>loss_val::Vector{Float32}</code>   Validation loss per epoch.</p></li></ul><p><strong>Description</strong></p><ol><li>Precomputes pairwise distances (<code>distance_layer</code>) and derivatives (<code>distance_derivatives</code>) for both training and validation sets.</li><li>Performs mini-batch gradient descent using <code>Enzyme.gradient</code> and <code>Flux.update!</code>.</li><li>Optionally computes forces in addition to energies in the loss function.</li><li>Applies adaptive learning rate: decays learning rate if validation loss does not improve for <code>patience</code> epochs.</li><li>Saves the model achieving the lowest validation loss (<code>best_model</code>).</li><li>Supports early stopping if the learning rate reaches <code>min_lr</code>.</li></ol><p><strong>Notes</strong></p><ul><li>Forces are computed using analytical derivatives of distances and backpropagated through the model.</li><li>The <code>λ</code> parameter balances energy and force contributions in the total loss.</li><li>Loss values are monitored to prevent NaNs; training will stop if a NaN is detected.</li></ul><p>```julia</p><p><strong>Assume models, x<em>train, y</em>train, x<em>val, y</em>val are defined</strong></p><p>best<em>model, train</em>loss, val<em>loss = train</em>model!(     model, x<em>train, y</em>train, x<em>val, y</em>val;     λ=0.5f0, forces=true, initial<em>lr=0.01, epochs=500, batch</em>size=16, verbose=true )</p><p>println(&quot;Training finished. Best validation loss: &quot;, minimum(val_loss))```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.dispatch" href="#SymmLearn.dispatch"><code>SymmLearn.dispatch</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dispatch(atoms, species_models::Vector{Chain}; lattice::Union{Nothing, Matrix{Float32}} = nothing)</code></pre><p>Public API function.  The developer version is called dispatch<em>train.  Computes the distance representation of a set of atoms (optionally within a lattice),   then applies the appropriate species-specific models via `dispatch</em>train`.  </p><p><strong>Arguments</strong></p><ul><li><code>atoms</code>: Atomic structure input, suitable for <code>distance_layer</code>.  </li><li><code>species_models::Vector{Chain}</code>: One neural network model per species.  </li><li><code>lattice::Union{Nothing, Matrix{Float32}}</code>: Optional lattice matrix for periodic systems.    Defaults to <code>nothing</code> (no periodic boundary conditions).</li></ul><p><strong>Returns</strong></p><ul><li><code>outputs</code>: Model predictions, either a scalar (single batch)    or a vector (batched input), depending on the input format.</li></ul><p>```julia</p><p><strong>Single configuration</strong></p><p>atoms = sample<em>atoms()  # returns a Vector{AtomInput} models = [model</em>H, model_O]  # one Flux.Chain per species result = dispatch(atoms, models)</p><p><strong>Batched configurations</strong></p><p>batch<em>atoms = [atoms1, atoms2, atoms3] batch</em>result = dispatch(batch<em>atoms, models) println(batch</em>result)```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.predict_forces" href="#SymmLearn.predict_forces"><code>SymmLearn.predict_forces</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">predict_forces(x, model; flat=false) -&gt; Array{Float32}</code></pre><p>Compute predicted atomic forces for a batch of structures using a trained model.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Input atomic structures, either a <code>Matrix{Vector{AtomInput}}</code> (batched) or compatible with <code>distance_layer</code>.</li><li><code>model</code>: Species-specific neural network models used for force prediction.</li><li><code>flat::Bool</code> (optional): If <code>true</code>, return forces flattened as a 1D vector;   if <code>false</code> (default), return a 3D array <code>(n_batches, n_atoms, 3)</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Array{Float32}</code>: Predicted forces for all atoms:<ul><li><code>(n_batches, n_atoms, 3)</code> if <code>flat=false</code></li><li>Flattened 1D array if <code>flat=true</code></li></ul></li></ul><p><strong>Description</strong></p><ol><li>Compute pairwise distances with <code>distance_layer</code>.</li><li>Compute distance derivatives with <code>distance_derivatives</code>.</li><li>For each batch, compute force contributions from model gradients.</li><li>Optionally flatten the resulting force array.</li></ol><p>```julia</p><p><strong>Assume x_test contains a batch of structures and models is defined</strong></p><p>forces = predict<em>forces(x</em>test, models) println(size(forces))  # (n<em>batches, n</em>atoms, 3)</p><p>forces<em>flat = predict</em>forces(x<em>test, models; flat=true) println(length(forces</em>flat))  # n<em>batches * n</em>atoms * 3```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.loss" href="#SymmLearn.loss"><code>SymmLearn.loss</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">loss(model, x, y; λ=1.0f0, forces=true) -&gt; Float32</code></pre><p>Compute the training loss as mean squared error on energies plus, optionally, a weighted force-matching term.</p><p>This is a user-level function; the developer version is <code>loss_train</code>.</p><p><strong>Arguments</strong></p><ul><li><code>model::Vector{Chain}</code>: Species-specific neural network models.</li><li><code>x</code>: Input atomic structure(s).</li><li><code>y</code>: Reference labels containing energies and forces.</li><li><code>λ::Float32</code> (optional): Weight for the force contribution. Default = 1.0.</li><li><code>forces::Bool</code> (optional): If true, include force loss. If false, only energy loss. Default = true.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float32</code>: Total loss (energy-only if <code>forces=false</code>, energy + λ·forces otherwise).</li></ul><p>```julia</p><p><strong>Assume models, x<em>batch, y</em>batch are defined</strong></p><p>total<em>loss = loss(models, x</em>batch, y<em>batch; λ=0.5f0, forces=true) println(&quot;Computed loss: &quot;, total</em>loss)```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/">« Examples</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Wednesday 12 November 2025 05:47">Wednesday 12 November 2025</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
