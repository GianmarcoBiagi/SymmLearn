<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>SymmLearn.jl Developer API · SymmLearn.jl</title><meta name="title" content="SymmLearn.jl Developer API · SymmLearn.jl"/><meta property="og:title" content="SymmLearn.jl Developer API · SymmLearn.jl"/><meta property="twitter:title" content="SymmLearn.jl Developer API · SymmLearn.jl"/><meta name="description" content="Documentation for SymmLearn.jl."/><meta property="og:description" content="Documentation for SymmLearn.jl."/><meta property="twitter:description" content="Documentation for SymmLearn.jl."/><meta property="og:url" content="https://github.com/GianmarcoBiagi/SymmLearn/developer/"/><meta property="twitter:url" content="https://github.com/GianmarcoBiagi/SymmLearn/developer/"/><link rel="canonical" href="https://github.com/GianmarcoBiagi/SymmLearn/developer/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/style.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">SymmLearn.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../installation/">Installation</a></li><li><a class="tocitem" href="../usage/">Usage</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../api/">API</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>SymmLearn.jl Developer API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>SymmLearn.jl Developer API</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/GianmarcoBiagi/SymmLearn" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="SymmLearn.jl-Developer-API"><a class="docs-heading-anchor" href="#SymmLearn.jl-Developer-API">SymmLearn.jl Developer API</a><a id="SymmLearn.jl-Developer-API-1"></a><a class="docs-heading-anchor-permalink" href="#SymmLearn.jl-Developer-API" title="Permalink"></a></h1><p>This page lists all the internal functions, structs, and utilities of <code>SymmLearn.jl</code>.   These are mainly intended for developers and advanced users who want to understand or extend the library.  </p><p>The functions here are <strong>not included in the main menu</strong>, but are fully searchable through the search bar.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.charge_to_element" href="#SymmLearn.charge_to_element"><code>SymmLearn.charge_to_element</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">charge_to_element :: Dict{Int, String}</code></pre><p>Inverse mapping of <code>element_to_charge</code>. Maps atomic numbers (charges) to their element symbols.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">charge_to_element[6]  # Returns &quot;C&quot;
charge_to_element[79] # Returns &quot;Au&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.element_to_charge" href="#SymmLearn.element_to_charge"><code>SymmLearn.element_to_charge</code></a> — <span class="docstring-category">Constant</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">element_to_charge :: Dict{String, Int}</code></pre><p>Dictionary mapping chemical element symbols (as <code>String</code>s) to their atomic numbers (as <code>Int</code>s).   This is used to assign a charge or atomic number to an element for neural network input preprocessing.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Retrieve atomic number of Carbon
carbon_atomic_number = element_to_charge[&quot;C&quot;]
println(carbon_atomic_number)  # Output: 6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.AtomInput" href="#SymmLearn.AtomInput"><code>SymmLearn.AtomInput</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AtomInput(species::Int, coord::AbstractVector)</code></pre><p>Container for one atom in a structure.</p><ul><li><code>species</code>: integer index in 1..K identifying the species.</li><li><code>coord</code>: atomic coordinates as a vector.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.G1Input" href="#SymmLearn.G1Input"><code>SymmLearn.G1Input</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">G1Input(species::Int, dist::AbstractMatrix)</code></pre><p>Container for one atom in a structure.</p><ul><li><code>species</code>: integer index in 1..K identifying the species.</li><li><code>dist</code>: matrix of distances between the atom and the others.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.G1Layer" href="#SymmLearn.G1Layer"><code>SymmLearn.G1Layer</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">G1Layer(W_eta::Vector{Float32}, W_Fs::Vector{Float32}, cutoff::Float32, charge::Float32)</code></pre><p>Custom neural network layer with weights and system-specific parameters.</p><p><strong>Fields</strong></p><ul><li><code>W_eta::Vector{Float32}</code>: Weight vector for the &quot;eta&quot; connection.</li><li><code>W_Fs::Vector{Float32}</code>: Weight vector for the &quot;Fs&quot; connection.</li><li><code>cutoff::Float32</code>: Cutoff radius for interactions.</li><li><code>charge::Float32</code>: Atomic charge associated with the layer.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">W_eta_example = rand(Float32, 5)
W_Fs_example  = rand(Float32, 5)
cutoff_example = 5.0f0
charge_example = 1.0f0

layer = G1Layer(W_eta_example, W_Fs_example, cutoff_example, charge_example)
println(&quot;Layer created: &quot;, layer)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.G1Layer-Tuple{AbstractMatrix{Float32}}" href="#SymmLearn.G1Layer-Tuple{AbstractMatrix{Float32}}"><code>SymmLearn.G1Layer</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">(layer::G1Layer)(x::AbstractMatrix{Float32}) -&gt; Matrix{Float32}</code></pre><p>Apply the <code>G1Layer</code> to a batch of atomic distances, computing radial symmetry function outputs.</p><p><strong>Arguments</strong></p><ul><li><code>layer::G1Layer</code>: Layer instance with fields:<ul><li><code>W_eta::Vector{Float32}</code>: Width parameters for each symmetry function.</li><li><code>W_Fs::Vector{Float32}</code>: Peak positions for each symmetry function.</li><li><code>cutoff::Float32</code>: Cutoff radius for neighbor interactions.</li><li><code>charge::Float32</code>: Atomic charge scaling factor.</li></ul></li><li><code>x::AbstractMatrix{Float32}</code>: Distance matrix of shape <code>(n_batch, n_neighbors)</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{Float32}</code>: Symmetry function outputs, shape <code>(n_features, n_batch)</code>, where <code>n_features = size(layer.W_eta, 1)</code>.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">layer = G1Layer(5, 2.5f0, 1.0f0)  # 5 symmetry functions, cutoff 2.5, charge 1.0
x = rand(Float32, 3, 10)          # 3 atoms, 10 neighbors each
output = layer(x)                 # Output shape: (5, 3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.G1Layer-Tuple{Int64, Float32, Float32}" href="#SymmLearn.G1Layer-Tuple{Int64, Float32, Float32}"><code>SymmLearn.G1Layer</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">G1Layer(N_G1::Int, cutoff::Float32, charge::Float32; seed::Union{Int,Nothing}=nothing) -&gt; G1Layer</code></pre><p>Create a G1 radial symmetry function layer with physically-informed initialization.</p><ul><li><code>Fs</code> are distributed linearly across the distance range [r_min, cutoff] with small random jitter.</li><li><code>eta</code> values are set according to the average spacing between <code>Fs</code>, with slight random perturbations.</li><li>This initialization avoids extreme contributions from very small distances that can bias energy predictions.</li></ul><p><strong>Arguments</strong></p><ul><li><code>N_G1::Int</code>: Number of G1 functions.</li><li><code>cutoff::Float32</code>: Cutoff radius for interatomic interactions.</li><li><code>charge::Float32</code>: Atomic charge used as scaling factor.</li><li><code>seed::Int</code> or <code>nothing</code>: Optional RNG seed for reproducibility.</li></ul><p><strong>Returns</strong></p><ul><li><code>G1Layer</code> instance with initialized <code>Fs</code> and <code>eta</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.Sample" href="#SymmLearn.Sample"><code>SymmLearn.Sample</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Sample(energy::Float32, forces::Array{Float32,2})</code></pre><p>Container for target data of one atomic configuration.</p><p><strong>Fields</strong></p><ul><li><code>energy::Float32</code>: Total energy of the configuration.</li><li><code>forces::Array{Float32,2}</code>: Forces acting on the atoms, shape (num_atoms, 3).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.batch_indices-Tuple{Any, Any}" href="#SymmLearn.batch_indices-Tuple{Any, Any}"><code>SymmLearn.batch_indices</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">batch_indices(n::Int, batchsize::Int) -&gt; Vector{Vector{Int}}</code></pre><p>Generate mini-batch indices for stochastic gradient descent.</p><p><strong>Arguments</strong></p><ul><li><code>n::Int</code>: Total number of samples in the dataset.</li><li><code>batchsize::Int</code>: Size of each mini-batch.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Vector{Int}}</code>: Shuffled list of index vectors, each representing a mini-batch.   The last batch may contain fewer than <code>batchsize</code> elements if <code>n</code> is not divisible by <code>batchsize</code>.</li></ul><p><strong>Notes</strong></p><ul><li>The indices are shuffled randomly each call to ensure stochasticity.</li><li>Useful for iterating over training data in <code>train_model!</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.build_branch" href="#SymmLearn.build_branch"><code>SymmLearn.build_branch</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_branch(atom::String, G1_number::Int, R_cutoff::Float32; depth=2, seed=nothing) -&gt; Chain</code></pre><p>Construct a per-species neural network subbranch for atomic energy prediction.</p><p><strong>Arguments</strong></p><ul><li><code>atom::String</code>: Atomic species name.</li><li><code>G1_number::Int</code>: Number of radial G1 symmetry functions.</li><li><code>R_cutoff::Float32</code>: Cutoff radius for the G1Layer.</li><li><code>depth::Int</code> (optional): Complexity of hidden layers. <code>1</code> or <code>2</code>. Default = 2.</li><li><code>seed::Int</code> or <code>nothing</code> (optional): RNG seed for G1Layer initialization.</li></ul><p><strong>Returns</strong></p><ul><li><code>Chain</code>: Flux.jl neural network chain consisting of:<ul><li><code>G1Layer</code> with scaled atomic charge.</li><li>LayerNorm layers.</li><li>Dense layers with <code>swish</code> activation.</li><li>Final Dense layer outputs scalar atomic energy.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.build_species_models-Tuple{Vector{String}, Dict{String, Int64}, Int64, Float32}" href="#SymmLearn.build_species_models-Tuple{Vector{String}, Dict{String, Int64}, Int64, Float32}"><code>SymmLearn.build_species_models</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">build_species_models(unique_species::Vector{String}, species_idx::Dict{String,Int}, G1_number::Int, R_cutoff::Float32)</code></pre><p>Creates an array of Flux <code>Chain</code> models, one for each unique species.   The array is indexed according to <code>species_idx</code>, so that each species can be dispatched to the correct model based on its numeric index.  </p><p><strong>Arguments</strong></p><ul><li><code>unique_species::Vector{String}</code>: List of species names.</li><li><code>species_idx::Dict{String,Int}</code>: Mapping from species name to numeric index.</li><li><code>G1_number::Int</code>: Number of neurons in the G1Layer.</li><li><code>R_cutoff::Float32</code>: Cutoff radius for the G1Layer.</li></ul><p><strong>Returns</strong></p><ul><li><code>species_models::Vector{Chain}</code>: Array of models, ready for Enzyme differentiation.</li></ul><pre><code class="language-julia hljs">unique_species = [&quot;H&quot;, &quot;O&quot;]
species_idx = Dict(&quot;H&quot;=&gt;1, &quot;O&quot;=&gt;2)
G1_number = 5
R_cutoff = 5.0f0

models = build_species_models(unique_species, species_idx, G1_number, R_cutoff; depth=2)
println(models[1])  # model for H
println(models[2])  # model for O</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.calculate_force-Tuple{AbstractVector, Any}" href="#SymmLearn.calculate_force-Tuple{AbstractVector, Any}"><code>SymmLearn.calculate_force</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calculate_force(model, x::AbstractVector) -&gt; AbstractVector</code></pre><p>Compute the negative gradient of the scalar model output w.r.t. input <code>x</code>, i.e., the predicted forces.</p><p><strong>Arguments</strong></p><ul><li><code>model::Function</code>: Callable model.</li><li><code>x::AbstractVector</code>: Single input structure.</li></ul><p><strong>Returns</strong></p><ul><li><code>AbstractVector</code>: Predicted forces of same size as <code>x</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.d_pbc-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, AbstractMatrix{&lt;:Real}}" href="#SymmLearn.d_pbc-Tuple{AbstractVector{&lt;:Real}, AbstractVector{&lt;:Real}, AbstractMatrix{&lt;:Real}}"><code>SymmLearn.d_pbc</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">d_pbc(atom1, atom2, lattice; coords=:cartesian, return_image=false)</code></pre><p>Compute the minimum-image distance between two atoms under periodic boundary conditions (PBC).</p><p><strong>Arguments</strong></p><ul><li><code>atom1::AbstractVector{&lt;:Real}</code>: Coordinates of the first atom.</li><li><code>atom2::AbstractVector{&lt;:Real}</code>: Coordinates of the second atom.</li><li><code>lattice::AbstractMatrix{&lt;:Real}</code>: 3×3 lattice matrix where columns are lattice vectors.</li><li><code>coords::Symbol</code>: Either <code>:cartesian</code> (default) or <code>:fractional</code> to specify the input coordinate type.</li><li><code>return_image::Bool</code>: If true, also return the minimum-image vector in Cartesian coordinates and the integer lattice translation vector applied.</li></ul><p><strong>Returns</strong></p><ul><li><code>d::Float32</code>: Minimum distance under PBC.</li><li>Optionally <code>(d, rvec, n)</code> if <code>return_image=true</code>:<ul><li><code>rvec::Vector{Float32}</code>: Cartesian vector along the minimum-image direction.</li><li><code>n::Vector{Int}</code>: Integer lattice translation indices applied to obtain the minimum image.</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>Works for both orthogonal and non-orthogonal lattices.</li><li>Implements the minimum-image convention in fractional coordinates.</li><li>Supports input coordinates in either Cartesian or fractional form.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.data_preprocess-Tuple{Any, Any, Any}" href="#SymmLearn.data_preprocess-Tuple{Any, Any, Any}"><code>SymmLearn.data_preprocess</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">data_preprocess(input_data, energies, forces; split=[0.6, 0.2, 0.2])</code></pre><p>Preprocess input features and target data for neural network training. The dataset is split, energies normalized, forces rescaled consistently with energies, and targets repackaged into <code>Sample</code> structs.</p><p><strong>Arguments</strong></p><ul><li><code>input_data::Array{&lt;:Real,2}</code>: Input features of shape <code>(N_structures, 3 * n_atoms)</code>.</li><li><code>energies::Vector{Float32}</code>: Total system energies for each structure.</li><li><code>forces::Array{Float32,3}</code>: Atomic forces of shape <code>(N_structures, n_atoms, 3)</code>.</li><li><code>split::Vector{Float64}</code> (optional): Fractions for train/validation/test splits, must sum to 1. Default <code>[0.6, 0.2, 0.2]</code>.</li></ul><p><strong>Returns</strong></p><p>A tuple containing:</p><ul><li><code>x_train::Array, y_train::Vector{Sample}</code>: Training inputs and targets.</li><li><code>x_val::Array, y_val::Vector{Sample}</code>: Validation inputs and targets.</li><li><code>x_test::Array, y_test::Vector{Sample}</code>: Test inputs and targets.</li><li><code>(energy_mean::Float32, energy_std::Float32)</code>: Statistics used for energy normalization.</li></ul><p><strong>Notes</strong></p><ul><li>Energies are normalized by Z-score (zero mean, unit variance).</li><li>Forces are scaled by the same energy standard deviation (<code>energy_std</code>).</li><li>Targets are returned as <code>Sample</code> structs with:<ul><li><code>.energy</code>: normalized scalar energy.</li><li><code>.forces</code>: rescaled force matrix <code>(n_atoms, 3)</code>.</li></ul></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.dispatch-Tuple{Any, Vector{Flux.Chain}}" href="#SymmLearn.dispatch-Tuple{Any, Vector{Flux.Chain}}"><code>SymmLearn.dispatch</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dispatch(atoms, species_models::Vector{Chain}; lattice::Union{Nothing, Matrix{Float32}} = nothing)</code></pre><p>Public API function.  The developer version is called dispatch<em>train.  Computes the distance representation of a set of atoms (optionally within a lattice),   then applies the appropriate species-specific models via `dispatch</em>train`.  </p><p><strong>Arguments</strong></p><ul><li><code>atoms</code>: Atomic structure input, suitable for <code>distance_layer</code>.  </li><li><code>species_models::Vector{Chain}</code>: One neural network model per species.  </li><li><code>lattice::Union{Nothing, Matrix{Float32}}</code>: Optional lattice matrix for periodic systems.    Defaults to <code>nothing</code> (no periodic boundary conditions).</li></ul><p><strong>Returns</strong></p><ul><li><code>outputs</code>: Model predictions, either a scalar (single batch)    or a vector (batched input), depending on the input format.</li></ul><p>```julia</p><p><strong>Single configuration</strong></p><p>atoms = sample<em>atoms()  # returns a Vector{AtomInput} models = [model</em>H, model_O]  # one Flux.Chain per species result = dispatch(atoms, models)</p><p><strong>Batched configurations</strong></p><p>batch<em>atoms = [atoms1, atoms2, atoms3] batch</em>result = dispatch(batch<em>atoms, models) println(batch</em>result)```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.dispatch_train-Tuple{Matrix{SymmLearn.G1Input}, Vector{Flux.Chain}}" href="#SymmLearn.dispatch_train-Tuple{Matrix{SymmLearn.G1Input}, Vector{Flux.Chain}}"><code>SymmLearn.dispatch_train</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dispatch_train(distances::Matrix{G1Input}, species_models::Vector{Chain})</code></pre><p>Apply the correct per-species neural network to a batch of atomic configurations.</p><p><strong>Description</strong></p><p>This is the <strong>batch version</strong> of <code>dispatch_train</code>.   Each row of <code>distances</code> represents a batch element, and each column represents an atom. The function applies the corresponding species model to each atom across all batches, then aggregates per-atom outputs into a scalar per batch.</p><p>This is a developer-level function; the public API is <code>dispatch</code>.</p><p><strong>Arguments</strong></p><ul><li><code>distances::Matrix{G1Input}</code>: Batched atomic inputs of size <code>(n_batches, n_atoms)</code>.   Each entry contains <code>species::Int</code> and <code>dist::Vector{Float32}</code>.   Species is assumed consistent across batches for each atom.</li><li><code>species_models::Vector{Chain}</code>: One neural network model per species.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float32}</code>: Vector of length <code>n_batches</code>, each element is the aggregated scalar prediction  (sum over atoms) for that batch.</li></ul><p><strong>See also</strong></p><p><code>dispatch_train(distances::Vector{G1Input}, species_models::Vector{Chain})</code> for a single-configuration version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.dispatch_train-Tuple{Vector{SymmLearn.G1Input}, Vector{Flux.Chain}}" href="#SymmLearn.dispatch_train-Tuple{Vector{SymmLearn.G1Input}, Vector{Flux.Chain}}"><code>SymmLearn.dispatch_train</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">dispatch_train(distances::Vector{G1Input}, species_models::Vector{Chain})</code></pre><p>Apply the correct per-species neural network to a single atomic configuration.</p><p><strong>Description</strong></p><p>This is the <strong>single-configuration version</strong> of <code>dispatch_train</code>.   For each atom in the input vector, the function applies the corresponding neural network from <code>species_models</code> based on the atom&#39;s <code>species</code> field. The outputs are summed to produce a scalar prediction for the entire configuration.  </p><p>This is a developer-level function; the public API is <code>dispatch</code>.</p><p><strong>Arguments</strong></p><ul><li><code>distances::Vector{G1Input}</code>: Vector of atomic inputs for one configuration,   each element containing the atom&#39;s <code>species</code> ID and neighbor distances.</li><li><code>species_models::Vector{Chain}</code>: One neural network model per species, indexed by <code>species</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float32</code>: Aggregated scalar output for the configuration (sum of per-atom predictions).</li></ul><p><strong>See also</strong></p><p><code>dispatch_train(distances::Matrix{G1Input}, species_models::Vector{Chain})</code> for the batched version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.distance_derivatives-Tuple{Matrix{Vector{SymmLearn.AtomInput}}}" href="#SymmLearn.distance_derivatives-Tuple{Matrix{Vector{SymmLearn.AtomInput}}}"><code>SymmLearn.distance_derivatives</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">distance_derivatives(input::Matrix{Vector{AtomInput}}; lattice=nothing)</code></pre><p>Compute analytical derivatives of pairwise interatomic distances for a batch of atomic systems.</p><p><strong>Description</strong></p><p>This is the <strong>batch version</strong> of <code>distance_derivatives</code>. Each row of <code>input</code> represents a separate  atomic configuration. For each configuration, the derivatives of distances between every pair of  atoms are computed. If <code>lattice</code> is provided, derivatives use the <strong>minimum-image convention</strong> under  periodic boundary conditions (PBC); otherwise, standard Cartesian derivatives are used.</p><p><strong>Arguments</strong></p><ul><li><code>input::Matrix{Vector{AtomInput}}</code>: 2D array of atomic systems. Each element is a vector of <code>AtomInput</code> objects containing <code>.coord</code> fields with 3D coordinates.</li><li><code>lattice::Union{Nothing, Matrix{Float32}}</code>: Optional 3×3 lattice matrix for PBC.</li></ul><p><strong>Returns</strong></p><ul><li><code>Array{Float32, 4}</code>: Tensor of shape <code>(n_batch, n_atoms, n_atoms-1, 3)</code>:<ul><li><code>outputs[b, i, j, :]</code> → derivative of distance <code>d(i, j+1)</code> w.r.t atom <code>i</code>.</li><li><code>outputs[b, j+1, i, :]</code> → derivative of distance <code>d(i, j+1)</code> w.r.t atom <code>j+1</code>.</li><li>Derivatives w.r.t. other atoms are zero (not stored).</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>If two atoms coincide (distance numerically zero), the derivative is set to <code>(0, 0, 0)</code>.</li><li>See also <code>distance_derivatives(input::Vector{AtomInput})</code> for a single-configuration version.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.distance_derivatives-Tuple{Vector{SymmLearn.AtomInput}}" href="#SymmLearn.distance_derivatives-Tuple{Vector{SymmLearn.AtomInput}}"><code>SymmLearn.distance_derivatives</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">distance_derivatives(input::Vector{AtomInput}; lattice=nothing)</code></pre><p>Compute analytical derivatives of pairwise interatomic distances for a single atomic system.</p><p><strong>Description</strong></p><p>This is the <strong>single-configuration version</strong> of <code>distance_derivatives</code>. The function computes  derivatives of distances between every pair of atoms in the input vector. If <code>lattice</code> is provided,  the <strong>minimum-image convention</strong> under periodic boundary conditions (PBC) is applied; otherwise,  standard Cartesian derivatives are used.</p><p><strong>Arguments</strong></p><ul><li><code>input::Vector{AtomInput}</code>: Vector of atoms. Each <code>AtomInput</code> must have a <code>.coord</code> field with 3D coordinates.</li><li><code>lattice::Union{Nothing, Matrix{Float32}}</code>: Optional 3×3 lattice matrix for PBC.</li></ul><p><strong>Returns</strong></p><ul><li><code>Array{Float32, 3}</code>: Tensor of shape <code>(n_atoms, n_atoms-1, 3)</code>:<ul><li><code>outputs[i, j, :]</code> → derivative of distance <code>d(i, j+1)</code> w.r.t atom <code>i</code>.</li><li><code>outputs[j+1, i, :]</code> → derivative of distance <code>d(i, j+1)</code> w.r.t atom <code>j+1</code>.</li><li>Derivatives w.r.t. other atoms are zero (not stored).</li></ul></li></ul><p><strong>Notes</strong></p><ul><li>If two atoms coincide (distance numerically zero), the derivative is set to <code>(0, 0, 0)</code>.</li><li>See also <code>distance_derivatives(input::Matrix{Vector{AtomInput}})</code> for the batch version.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.distance_layer-Tuple{Matrix{Vector{SymmLearn.AtomInput}}}" href="#SymmLearn.distance_layer-Tuple{Matrix{Vector{SymmLearn.AtomInput}}}"><code>SymmLearn.distance_layer</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">distance_layer(input::Matrix{Vector{AtomInput}}; lattice=nothing)</code></pre><p>Compute pairwise distances for a batch of atomic configurations.</p><p><strong>Description</strong></p><p>This is the <strong>batch version</strong> of <code>distance_layer</code>, where each row of the matrix represents  a separate configuration of atoms. Distances are computed between every pair of atoms  in each configuration. If <code>lattice</code> is provided, the <strong>minimum-image convention</strong> under  periodic boundary conditions (PBC) is applied. Otherwise, simple Cartesian distances are used.</p><p><strong>Arguments</strong></p><ul><li><code>input::Matrix{Vector{AtomInput}}</code>: A matrix of batches. Each element is a vector of <code>AtomInput</code> objects containing <code>.species::Int</code> and <code>.coord::AbstractVector</code> (3D coordinates at least).</li><li><code>lattice::Union{Nothing, Matrix{Float32}}</code>: Optional 3×3 lattice matrix for PBC.</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{G1Input}</code>: Same shape as <code>input</code>. Each <code>G1Input</code> contains <code>species</code> and a 1×(N-1) matrix of distances.</li></ul><p><strong>See also</strong></p><p><code>distance_layer(input::Vector{AtomInput})</code> for computing distances for a single atomic configuration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.distance_layer-Tuple{Vector{SymmLearn.AtomInput}}" href="#SymmLearn.distance_layer-Tuple{Vector{SymmLearn.AtomInput}}"><code>SymmLearn.distance_layer</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">distance_layer(input::Matrix{Vector{AtomInput}}; lattice=nothing)</code></pre><p>Compute pairwise distances for a batch of atomic configurations.</p><p><strong>Description</strong></p><p>This is the <strong>batch version</strong> of <code>distance_layer</code>, where each row of the matrix represents  a separate configuration of atoms. Distances are computed between every pair of atoms  in each configuration. If <code>lattice</code> is provided, the <strong>minimum-image convention</strong> under  periodic boundary conditions (PBC) is applied. Otherwise, simple Cartesian distances are used.</p><p><strong>Arguments</strong></p><ul><li><code>input::Matrix{Vector{AtomInput}}</code>: A matrix of batches. Each element is a vector of <code>AtomInput</code> objects containing <code>.species::Int</code> and <code>.coord::AbstractVector</code> (3D coordinates at least).</li><li><code>lattice::Union{Nothing, Matrix{Float32}}</code>: Optional 3×3 lattice matrix for PBC.</li></ul><p><strong>Returns</strong></p><ul><li><code>Matrix{G1Input}</code>: Same shape as <code>input</code>. Each <code>G1Input</code> contains <code>species</code> and a 1×(N-1) matrix of distances.</li></ul><p><strong>See also</strong></p><p><code>distance_layer(input::Vector{AtomInput})</code> for computing distances for a single atomic configuration.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.energy_loss-Tuple{Any, Any, Any}" href="#SymmLearn.energy_loss-Tuple{Any, Any, Any}"><code>SymmLearn.energy_loss</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">energy_loss(model, x, y) -&gt; AbstractArray</code></pre><p>Compute the squared error between predicted energy and reference energy.</p><p><strong>Arguments</strong></p><ul><li><code>model::Function</code>: A callable model.</li><li><code>x</code>: Input structure.</li><li><code>y</code>: Reference scalar energy.</li></ul><p><strong>Returns</strong></p><ul><li>Squared error as an array.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.extract_data-Tuple{String}" href="#SymmLearn.extract_data-Tuple{String}"><code>SymmLearn.extract_data</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extract_data(path::String)</code></pre><p><strong>Description:</strong></p><p>Extracts structural and energetic information from atomic configurations in <code>.xyz</code> format using <code>ExtXYZ</code>.</p><p><strong>Arguments:</strong></p><ul><li><code>path::String</code>: Path to the file containing the data.</li></ul><p><strong>Returns:</strong></p><p>A tuple containing:</p><ol><li><code>atoms_in_a_cell::Int</code>: Number of atoms in one cell (assumed constant across frames).</li><li><code>species::Vector{String}</code>: Species of atoms in the first frame.</li><li><code>unique_species::Vector{String}</code>: Unique species present in the system.</li><li><code>all_cells::Vector{Matrix{Float32}}</code>: List of cell matrices for each configuration.</li><li><code>dataset::Array{Float32, 3}</code>: 3D array with data per configuration:<ul><li>Rows 1–3: Atomic positions (x, y, z).</li><li>Rows 4–6: Forces (fx, fy, fz).</li></ul></li><li><code>all_energies::Vector{Float32}</code>: Energies for each configuration.</li></ol><p><strong>Functionality:</strong></p><ol><li><strong>Reading the data</strong>: The function first reads the data from the provided path using <code>read_frames(path)</code>.</li><li><strong>Extracting number of configurations</strong>: It calculates the total number of configurations by checking the size of the data.</li><li><strong>Pre-allocating arrays</strong>: The function allocates memory for arrays to store the energies, cell matrices, atomic data, and forces for each configuration.</li><li><strong>Species extraction</strong>: It extracts the unique species (elements) used in the configurations and stores them in the <code>species</code> array.</li><li><strong>Data extraction</strong>:<ul><li>The function extracts the cell matrices for each configuration.</li><li>It also extracts the total energy for each configuration.</li><li>The dataset is populated with atomic charges, positions, and forces for each atom in each configuration.</li></ul></li><li><strong>Returning the data</strong>: After all data has been extracted and stored in the arrays, the function returns the extracted data as a tuple.</li></ol><p><strong>Example Usage:</strong></p><pre><code class="language-julia hljs">atoms_in_a_cell, species,unique_species, all_cells, dataset, all_energies = extract_data(&quot;path/to/data.xyz&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.extract_energies-Tuple{SymmLearn.Sample}" href="#SymmLearn.extract_energies-Tuple{SymmLearn.Sample}"><code>SymmLearn.extract_energies</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extract_energies(x::Sample)</code></pre><p>Return the energy of a single <code>Sample</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x::Sample</code>: a single sample containing energy and forces.</li></ul><p><strong>Returns</strong></p><ul><li><code>energy::AbstractVector</code>: the energy stored in the sample.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.extract_energies-Tuple{Vector{SymmLearn.Sample}}" href="#SymmLearn.extract_energies-Tuple{Vector{SymmLearn.Sample}}"><code>SymmLearn.extract_energies</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extract_energies(X::Vector{Sample})</code></pre><p>Return the energies of a batch of samples.</p><p><strong>Arguments</strong></p><ul><li><code>X::Vector{Sample}</code>: A collection of <code>Sample</code> objects, each containing an energy vector.</li></ul><p><strong>Returns</strong></p><ul><li><code>energies_batch::Vector{Float32}</code>: 1D vector of length <code>n_batch</code>, where each element contains the first component of the energy of a sample.</li></ul><p><strong>Notes</strong></p><ul><li>The function extracts only the first element of each sample&#39;s <code>energy</code> field.</li><li>Output is always of type <code>Float32</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.extract_forces-Tuple{SymmLearn.Sample}" href="#SymmLearn.extract_forces-Tuple{SymmLearn.Sample}"><code>SymmLearn.extract_forces</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extract_forces(x::Sample)</code></pre><p>Return the forces of a single <code>Sample</code>.</p><p><strong>Arguments</strong></p><ul><li><code>x::Sample</code>: a single sample containing energy and forces.</li></ul><p><strong>Returns</strong></p><ul><li><code>forces::AbstractVector</code>: the forces stored in the sample.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.extract_forces-Tuple{Vector{SymmLearn.Sample}}" href="#SymmLearn.extract_forces-Tuple{Vector{SymmLearn.Sample}}"><code>SymmLearn.extract_forces</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">extract_forces(y::Vector{Sample}; ndims::Int=3)</code></pre><p>Extract and reshape atomic force vectors from a batch of samples.</p><p><strong>Arguments</strong></p><ul><li><code>y::Vector{Sample}</code>: A batch of <code>Sample</code> objects, each containing a <code>forces</code> field as a 2D array of shape <code>(n_atoms, 3)</code>.</li><li><code>ndims::Int=3</code>: Desired dimensionality of the returned array:<ul><li><code>3</code>: Returns a 3D array <code>(n_batch, n_atoms, 3)</code>  </li><li><code>2</code>: Returns a 2D array <code>(n_batch, n_atoms*3)</code>  </li><li><code>1</code>: Returns a 1D array <code>(n_batch*n_atoms*3)</code></li></ul></li></ul><p><strong>Returns</strong></p><ul><li>Array of <code>Float32</code> forces in the requested shape according to <code>ndims</code>.</li></ul><p><strong>Behavior</strong></p><ul><li>If <code>ndims == 3</code>, output shape is <code>(n_batch, n_atoms, 3)</code>.</li><li>If <code>ndims == 2</code>, output shape is <code>(n_batch, n_atoms*3)</code>.</li><li>If <code>ndims == 1</code>, output shape is <code>(n_batch*n_atoms*3)</code>.</li><li>Prints an error message if <code>ndims</code> is not 1, 2, or 3.</li></ul><p><strong>Notes</strong></p><ul><li>Assumes all samples have the same number of atoms.</li><li>Forces are extracted directly from the <code>forces</code> field of each sample.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.fc-Tuple{Float32, Float32}" href="#SymmLearn.fc-Tuple{Float32, Float32}"><code>SymmLearn.fc</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fc(Rij, Rc)</code></pre><p>Compute a smooth cutoff function for distances between particles.</p><p><strong>Arguments</strong></p><ul><li><code>Rij::Float32</code>: Distance between two particles.</li><li><code>Rc::Float32</code>: Cutoff distance. Returns 0 if <code>Rij &gt;= Rc</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float32</code>: Value of the smooth cutoff function. </li></ul><p><strong>Behavior</strong></p><ul><li>Returns 0 if <code>Rij &gt;= Rc</code>.</li><li>For <code>Rij &lt; Rc</code>, computes a smooth exponential decay using:   fc(Rij) = exp(1 - 1 / (1 - (Rij / Rc)^2))</li></ul><p>A small tolerance (<code>eps(Float32)</code>) is used to avoid numerical issues when <code>Rij</code> approaches <code>Rc</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.force_loss-Tuple{Any, AbstractVector, Any, Any}" href="#SymmLearn.force_loss-Tuple{Any, AbstractVector, Any, Any}"><code>SymmLearn.force_loss</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">force_loss(model, x::AbstractVector, f, f_matrix) -&gt; Float32</code></pre><p>Compute the mean squared error (MSE) between predicted and reference forces for a single atomic structure.</p><p><strong>Description</strong></p><p>This is the <strong>single-structure version</strong> of <code>force_loss</code>.   It calculates the predicted forces by applying the model to the input representation <code>x</code> and mapping gradients via <code>f_matrix</code>, then compares them to the reference forces <code>f</code> using MSE.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: Callable neural network model.</li><li><code>x::AbstractVector</code>: Input atomic structure or per-atom representation.</li><li><code>f::AbstractMatrix{Float32}</code>: Reference forces, shape <code>(num_atoms, 3)</code>.</li><li><code>f_matrix::AbstractArray{Float32, 3}</code>: Distance derivative matrix for mapping gradients to Cartesian forces.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float32</code>: Mean squared error between predicted and reference forces for the structure.</li></ul><p><strong>See also</strong></p><p><code>force_loss(model, X::Matrix{G1Input}, F::Array{Float32,3}, F_matrix::Array{Float32,4})</code> for the batched version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.force_loss-Tuple{Any, Matrix{SymmLearn.G1Input}, Array{Float32, 3}, Array{Float32, 4}}" href="#SymmLearn.force_loss-Tuple{Any, Matrix{SymmLearn.G1Input}, Array{Float32, 3}, Array{Float32, 4}}"><code>SymmLearn.force_loss</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">force_loss(model, X::Matrix{G1Input}, F::Array{Float32,3}, F_matrix::Array{Float32,4}) -&gt; Vector{Float32}</code></pre><p>Compute force losses for a batch of atomic structures.</p><p><strong>Description</strong></p><p>This is the <strong>batch version</strong> of <code>force_loss</code>.   Each row of <code>X</code> corresponds to one structure. The function computes the predicted forces for each structure using the provided model and derivative matrices, then evaluates the mean squared error (MSE) against the reference forces.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: Callable neural network model.</li><li><code>X::Matrix{G1Input}</code>: Batch of inputs, one row per structure.</li><li><code>F::Array{Float32,3}</code>: Reference forces for each structure, shape <code>(num_samples, num_atoms, 3)</code>.</li><li><code>F_matrix::Array{Float32,4}</code>: Force derivative matrices for each structure, shape <code>(num_samples, num_atoms, 3, 3)</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Vector{Float32}</code>: Force loss for each structure in the batch.</li></ul><p><strong>See also</strong></p><p><code>force_loss(model, x::AbstractVector, f, f_matrix)</code> for the single-structure version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.loss-Tuple{Any, Any, Any}" href="#SymmLearn.loss-Tuple{Any, Any, Any}"><code>SymmLearn.loss</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">loss(model, x, y; λ=1.0f0, forces=true) -&gt; Float32</code></pre><p>Compute the training loss as mean squared error on energies plus, optionally, a weighted force-matching term.</p><p>This is a user-level function; the developer version is <code>loss_train</code>.</p><p><strong>Arguments</strong></p><ul><li><code>model::Vector{Chain}</code>: Species-specific neural network models.</li><li><code>x</code>: Input atomic structure(s).</li><li><code>y</code>: Reference labels containing energies and forces.</li><li><code>λ::Float32</code> (optional): Weight for the force contribution. Default = 1.0.</li><li><code>forces::Bool</code> (optional): If true, include force loss. If false, only energy loss. Default = true.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float32</code>: Total loss (energy-only if <code>forces=false</code>, energy + λ·forces otherwise).</li></ul><p>```julia</p><p><strong>Assume models, x<em>batch, y</em>batch are defined</strong></p><p>total<em>loss = loss(models, x</em>batch, y<em>batch; λ=0.5f0, forces=true) println(&quot;Computed loss: &quot;, total</em>loss)```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.loss_train-NTuple{4, Any}" href="#SymmLearn.loss_train-NTuple{4, Any}"><code>SymmLearn.loss_train</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">loss_train(models, x, y, fconst; λ=1.0f0) -&gt; Float32</code></pre><p>Compute the combined energy and force loss for training.</p><p>This is a developer-level function; the public API is <code>loss</code>.</p><p><strong>Arguments</strong></p><ul><li><code>models</code>: Callable model(s) for energy prediction.</li><li><code>x</code>: Input structure(s).</li><li><code>y</code>: Reference energies corresponding to <code>x</code>.</li><li><code>fconst</code>: Precomputed force contributions (treated as constant).</li><li><code>λ::Float32</code> (optional): Weight for the force contribution. Default = 1.0.</li></ul><p><strong>Returns</strong></p><ul><li><code>Float32</code>: Total loss combining mean energy loss and weighted mean force term.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.maybe_decay_lr!-NTuple{7, Any}" href="#SymmLearn.maybe_decay_lr!-NTuple{7, Any}"><code>SymmLearn.maybe_decay_lr!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">maybe_decay_lr!(opt, current_lr, no_improve_count, patience, decay_factor, min_lr, epoch; verbose=false)</code></pre><p>Check whether the learning rate should be decayed based on validation performance.</p><p>If the number of consecutive epochs without improvement (<code>no_improve_count</code>) reaches <code>patience</code>, the learning rate is multiplied by <code>decay_factor</code>, but not below <code>min_lr</code>. The optimizer state is updated in place to preserve momentum terms.</p><p><strong>Arguments</strong></p><ul><li><code>opt</code>: Optimizer (e.g., <code>Flux.Optimise.Adam</code>) whose learning rate will be modified.</li><li><code>current_lr::Float32</code>: Current learning rate.</li><li><code>no_improve_count::Int</code>: Number of consecutive epochs without improvement.</li><li><code>patience::Int</code>: Number of epochs to wait before decaying LR.</li><li><code>decay_factor::Float32</code>: Factor to multiply learning rate when decaying.</li><li><code>min_lr::Float32</code>: Minimum allowed learning rate.</li><li><code>epoch::Int</code>: Current epoch number.</li><li><code>verbose::Bool=false</code>: Print information when learning rate is decayed.</li></ul><p><strong>Returns</strong></p><p>Tuple <code>(opt, current_lr, no_improve_count, stop_training::Bool)</code>:</p><ul><li><code>opt</code>: Updated optimizer with new learning rate if decayed.</li><li><code>current_lr</code>: Updated learning rate.</li><li><code>no_improve_count</code>: Reset to 0 if LR was decayed, else unchanged.</li><li><code>stop_training::Bool</code>: True if <code>current_lr</code> reached <code>min_lr</code>, signaling training should stop.</li></ul><p><strong>Notes</strong></p><ul><li>This function allows adaptive learning rate schedules without restarting training.</li><li>The optimizer’s momentum buffers remain intact.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.maybe_save_best!-NTuple{7, Any}" href="#SymmLearn.maybe_save_best!-NTuple{7, Any}"><code>SymmLearn.maybe_save_best!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">maybe_save_best!(model, loss_val, epoch, best_model, best_loss, best_epoch, no_improve_count; tol=1.0)</code></pre><p>Update the record of the best-performing model based on validation loss.</p><p>This function checks whether the current validation loss <code>loss_val</code> is smaller than <code>tol * best_loss</code>.   If the condition is met, the current model is considered an improvement:</p><ul><li><code>best_model</code> is updated via <code>deepcopy(model)</code>,</li><li><code>best_loss</code> is set to <code>loss_val</code>,</li><li><code>best_epoch</code> is updated to the current <code>epoch</code>,</li><li><code>no_improve_count</code> is reset to 0.</li></ul><p>If there is no improvement, only <code>no_improve_count</code> is incremented by 1.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: Current neural network model.</li><li><code>loss_val::Float32</code>: Validation loss for the current epoch.</li><li><code>epoch::Int</code>: Current epoch number.</li><li><code>best_model</code>: Model corresponding to the best observed validation loss.</li><li><code>best_loss::Float32</code>: Best validation loss recorded so far.</li><li><code>best_epoch::Int</code>: Epoch number when <code>best_model</code> was saved.</li><li><code>no_improve_count::Int</code>: Number of consecutive epochs without improvement.</li><li><code>tol::Float32=1.0</code>: Tolerance factor. A new model is considered better if <code>loss_val &lt; tol * best_loss</code>.</li></ul><p><strong>Returns</strong></p><p>Tuple <code>(best_model, best_loss, best_epoch, no_improve_count)</code> with updated values.</p><p><strong>Notes</strong></p><ul><li>Setting <code>tol &lt; 1.0</code> allows small tolerance before updating the best model.</li><li>This function is useful for implementing early stopping and adaptive learning rate strategies in training loops.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.partition-Tuple{Vector, Vector{Float64}}" href="#SymmLearn.partition-Tuple{Vector, Vector{Float64}}"><code>SymmLearn.partition</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">partition(data::Vector{&lt;:AbstractArray}, parts::Vector{Float64}; shuffle=true, rng=Random.GLOBAL_RNG)</code></pre><p>Split a list of datasets into multiple parts (e.g., train/val/test).</p><ul><li><code>data</code>: Vector of datasets (e.g., <code>[x, e, f]</code>), each can be array or vector of custom objects.</li><li><code>parts</code>: Vector of fractions summing to 1.0, e.g., <code>[0.7, 0.2, 0.1]</code>.</li><li><code>shuffle</code>: Whether to shuffle indices before splitting.</li><li><code>rng</code>: Random number generator.</li></ul><p>Returns a tuple of vectors of splits for each dataset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.predict_forces-Tuple{Any, Any}" href="#SymmLearn.predict_forces-Tuple{Any, Any}"><code>SymmLearn.predict_forces</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">predict_forces(x, model; flat=false) -&gt; Array{Float32}</code></pre><p>Compute predicted atomic forces for a batch of structures using a trained model.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Input atomic structures, either a <code>Matrix{Vector{AtomInput}}</code> (batched) or compatible with <code>distance_layer</code>.</li><li><code>model</code>: Species-specific neural network models used for force prediction.</li><li><code>flat::Bool</code> (optional): If <code>true</code>, return forces flattened as a 1D vector;   if <code>false</code> (default), return a 3D array <code>(n_batches, n_atoms, 3)</code>.</li></ul><p><strong>Returns</strong></p><ul><li><code>Array{Float32}</code>: Predicted forces for all atoms:<ul><li><code>(n_batches, n_atoms, 3)</code> if <code>flat=false</code></li><li>Flattened 1D array if <code>flat=true</code></li></ul></li></ul><p><strong>Description</strong></p><ol><li>Compute pairwise distances with <code>distance_layer</code>.</li><li>Compute distance derivatives with <code>distance_derivatives</code>.</li><li>For each batch, compute force contributions from model gradients.</li><li>Optionally flatten the resulting force array.</li></ol><p>```julia</p><p><strong>Assume x_test contains a batch of structures and models is defined</strong></p><p>forces = predict<em>forces(x</em>test, models) println(size(forces))  # (n<em>batches, n</em>atoms, 3)</p><p>forces<em>flat = predict</em>forces(x<em>test, models; flat=true) println(length(forces</em>flat))  # n<em>batches * n</em>atoms * 3```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.prepare_nn_data-Tuple{Array{Float32, 3}, Vector{String}, Vector{String}}" href="#SymmLearn.prepare_nn_data-Tuple{Array{Float32, 3}, Vector{String}, Vector{String}}"><code>SymmLearn.prepare_nn_data</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">prepare_nn_data(dataset::Array{Float32,3},
                species_order::Vector{String},
                unique_species::Vector{String})</code></pre><p>Convert a dataset of atomic positions and forces into atom-wise inputs for a neural network.</p><p><strong>Arguments</strong></p><ul><li><code>dataset</code>: Array of shape (6, num<em>atoms, num</em>samples).</li><li><code>species_order</code>: Vector of species strings, length = num_atoms, defining atom order.</li><li><code>unique_species</code>: Vector of unique species strings, used to build the mapping.</li></ul><p><strong>Returns</strong></p><ul><li><code>all_structures::Vector{Vector{AtomInput}}</code>:   Each element is a structure represented as a vector of atoms.</li><li><code>forces::Array{Float32,3}</code>:   Shape (num<em>samples, num</em>atoms, 3), atomic forces for each sample.</li><li><code>species_idx::Dict{String,Int}</code>:   Mapping from species name to integer index, consistent across atoms.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.train_model!-NTuple{5, Any}" href="#SymmLearn.train_model!-NTuple{5, Any}"><code>SymmLearn.train_model!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">train_model!(model, x_train, y_train, x_val, y_val, 
             λ=1.0f0; forces=true, initial_lr=0.01, min_lr=1e-6, decay_factor=0.1, 
             patience=50, epochs=1000, batch_size=32, verbose=false, lattice=nothing)</code></pre><p>Train a neural network model to predict total energies (and optionally forces)  for atomic structures using mini-batch gradient descent, adaptive learning rate,  and early stopping.</p><p><strong>Arguments</strong></p><ul><li><p><code>model::Flux.Chain</code>   Neural network to train. Can combine multiple branches for different atomic species.</p></li><li><p><code>x_train::Any</code>   Training atomic structures, either batched or compatible with <code>distance_layer</code>.</p></li><li><p><code>y_train::Vector{Sample}</code>   Ground-truth labels containing <code>.energy</code> and <code>.forces</code> for training.</p></li><li><p><code>x_val::Any</code>   Validation atomic structures, same format as <code>x_train</code>.</p></li><li><p><code>y_val::Vector{Sample}</code>   Ground-truth labels for validation.</p></li><li><p><code>λ::Float32</code> (default = 1.0)   Weight applied to the force loss relative to the energy loss.</p></li><li><p><code>forces::Bool</code> (default = true)   If true, include force loss in addition to energy loss.</p></li><li><p><code>initial_lr::Float32</code> (default = 0.01)   Initial learning rate for the Adam optimizer.</p></li><li><p><code>min_lr::Float32</code> (default = 1e-6)   Minimum allowed learning rate; training stops decaying when reached.</p></li><li><p><code>decay_factor::Float32</code> (default = 0.1)   Factor by which to multiply the learning rate if validation loss plateaus.</p></li><li><p><code>patience::Int</code> (default = 50)   Number of epochs without improvement before reducing the learning rate.</p></li><li><p><code>epochs::Int</code> (default = 1000)   Maximum number of training epochs.</p></li><li><p><code>batch_size::Int</code> (default = 32)   Number of structures per mini-batch.</p></li><li><p><code>verbose::Bool</code> (default = false)   If true, prints progress, learning rate changes, and final results.</p></li><li><p><code>lattice::Union{Nothing, Matrix{Float32}}</code> (default = nothing)   Optional 3×3 lattice matrix if distances should be computed under PBC.</p></li></ul><p><strong>Returns</strong></p><ul><li><p><code>best_model::Flux.Chain</code>   Model achieving the lowest validation loss during training.</p></li><li><p><code>loss_tr::Vector{Float32}</code>   Training loss per epoch.</p></li><li><p><code>loss_val::Vector{Float32}</code>   Validation loss per epoch.</p></li></ul><p><strong>Description</strong></p><ol><li>Precomputes pairwise distances (<code>distance_layer</code>) and derivatives (<code>distance_derivatives</code>) for both training and validation sets.</li><li>Performs mini-batch gradient descent using <code>Enzyme.gradient</code> and <code>Flux.update!</code>.</li><li>Optionally computes forces in addition to energies in the loss function.</li><li>Applies adaptive learning rate: decays learning rate if validation loss does not improve for <code>patience</code> epochs.</li><li>Saves the model achieving the lowest validation loss (<code>best_model</code>).</li><li>Supports early stopping if the learning rate reaches <code>min_lr</code>.</li></ol><p><strong>Notes</strong></p><ul><li>Forces are computed using analytical derivatives of distances and backpropagated through the model.</li><li>The <code>λ</code> parameter balances energy and force contributions in the total loss.</li><li>Loss values are monitored to prevent NaNs; training will stop if a NaN is detected.</li></ul><p>```julia</p><p><strong>Assume models, x<em>train, y</em>train, x<em>val, y</em>val are defined</strong></p><p>best<em>model, train</em>loss, val<em>loss = train</em>model!(     model, x<em>train, y</em>train, x<em>val, y</em>val;     λ=0.5f0, forces=true, initial<em>lr=0.01, epochs=500, batch</em>size=16, verbose=true )</p><p>println(&quot;Training finished. Best validation loss: &quot;, minimum(val_loss))```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.update_lr!-Tuple{Any, Any}" href="#SymmLearn.update_lr!-Tuple{Any, Any}"><code>SymmLearn.update_lr!</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">update_lr!(opt, new_lr)</code></pre><p>Recursively update the learning rate <code>eta</code> for all Adam optimizer instances contained within a possibly nested optimizer structure.</p><p><strong>Arguments</strong></p><ul><li><code>opt</code>: Optimizer or optimizer tree (e.g., <code>OptimiserChain</code>) potentially containing multiple Adam leaves.</li><li><code>new_lr::Float32</code>: New learning rate to assign.</li></ul><p><strong>Returns</strong></p><ul><li><code>opt</code>: The same optimizer object with updated learning rates.</li></ul><p><strong>Notes</strong></p><ul><li>Only Adam optimizers (<code>Flux.Optimise.Adam</code>) are modified.</li><li>Other optimizer types or wrappers are left unchanged.</li><li>This function modifies the optimizer in-place.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="SymmLearn.xyz_to_nn_input-Tuple{String}" href="#SymmLearn.xyz_to_nn_input-Tuple{String}"><code>SymmLearn.xyz_to_nn_input</code></a> — <span class="docstring-category">Method</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">xyz_to_nn_input(file_path::String)</code></pre><p>Process an XYZ file containing atomic structures and energies to generate datasets for neural network training.</p><p><strong>Arguments</strong></p><ul><li><code>file_path::String</code>: Path to the XYZ file containing coordinates, species, lattice cells, and energy values.</li></ul><p><strong>Returns</strong></p><p>A tuple with:</p><ol><li><code>x_train::Array, y_train::Vector{Sample}</code>: Training inputs and targets.</li><li><code>x_val::Array, y_val::Vector{Sample}</code>: Validation inputs and targets.</li><li><code>x_test::Array, y_test::Vector{Sample}</code>: Test inputs and targets.</li><li><code>(energy_mean::Float32, energy_std::Float32)</code>: Energy normalization statistics.</li><li><code>unique_species::Vector{String}</code>: Unique atomic species in the dataset.</li><li><code>species_idx::Dict{String,Int}</code>: Mapping from species to integer indices.</li><li><code>all_cells::Vector{Matrix{Float32}}</code>: Lattice cell matrices for each configuration.</li></ol><p><strong>Description</strong></p><p>Steps performed:</p><ol><li>Extract structures, species, cells, and energies with <code>extract_data</code>.</li><li>Convert positions and forces into atom-wise inputs with <code>prepare_nn_data</code>.</li><li>Normalize energies and rescale forces consistently, then split into train/val/test sets with <code>data_preprocess</code>.</li></ol><p><strong>Dependencies</strong></p><ul><li><code>extract_data(file_path)</code>: Parses raw atomic data from the XYZ file.  </li><li><code>prepare_nn_data(dataset, species, unique_species)</code>: Builds NN inputs and forces arrays.  </li><li><code>data_preprocess(nn_input_dataset, all_energies, all_forces)</code>: Normalizes and splits the dataset.</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">file_path = &quot;example_structures.xyz&quot;
x_train, y_train, x_val, y_val, x_test, y_test, (energy_mean, energy_std), unique_species, species_idx, all_cells = xyz_to_nn_input(file_path)
println(&quot;Training set size: &quot;, length(x_train))
println(&quot;Unique species: &quot;, unique_species)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/GianmarcoBiagi/SymmLearn">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Wednesday 12 November 2025 05:47">Wednesday 12 November 2025</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
